<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Construction Clicker</title>
    <link rel="icon" type="image/x-icon" href="images.png">
    <style>
        :root {
            --primary-color: #f39c12;
            --secondary-color: #3498db;
            --dark-color: #2c3e50;
            --light-color: #ecf0f1;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--light-color);
            color: var(--dark-color);
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            grid-template-rows: auto 1fr auto;
            grid-template-areas: 
                "header header header"
                "left-panel main right-panel"
                "footer footer footer";
            min-height: 100vh;
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
            gap: 15px;
        }
        
        header {
            grid-area: header;
            text-align: center;
            padding: 10px;
            background-color: var(--dark-color);
            color: var(--light-color);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .resource-display {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .resource {
            padding: 5px 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            min-width: 120px;
        }
        
        .left-panel {
            grid-area: left-panel;
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            max-height: 80vh;
        }
        
        .main {
            grid-area: main;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .right-panel {
            grid-area: right-panel;
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            max-height: 80vh;
        }
        
        footer {
            grid-area: footer;
            text-align: center;
            padding: 10px;
            background-color: var(--dark-color);
            color: var(--light-color);
            border-radius: 8px;
            margin-top: auto;
        }
        
        .game-area {
            position: relative;
            width: 250px;
            height: 250px;
            margin: 20px auto;
        }
        
        .click-button {
            font-size: 80px;
            background: none;
            border: none;
            cursor: pointer;
            transition: transform 0.1s;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        
        .click-button:active {
            transform: translate(-50%, -50%) scale(0.8);
        }
        
        .cursor {
            position: absolute;
            font-size: 24px;
            transform-origin: center;
            z-index: 5;
        }
        
        .floating-text {
            position: absolute;
            font-weight: bold;
            animation: float-up 1.5s forwards;
            z-index: 15;
            pointer-events: none;
        }
        
        @keyframes float-up {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            80% {
                opacity: 0.8;
            }
            100% {
                opacity: 0;
                transform: translateY(-100px);
            }
        }
        
        .section-title {
            margin: 15px 0 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--primary-color);
            color: var(--dark-color);
        }
        
        .upgrade-item, .building-item, .rebirth-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            background-color: #f9f9f9;
            transition: background-color 0.2s;
        }
        
        .upgrade-item:hover, .building-item:hover, .rebirth-item:hover {
            background-color: #f0f0f0;
        }
        
        .button {
            padding: 8px 12px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .button:hover {
            background-color: #e67e22;
        }
        
        .button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .tab-container {
            display: flex;
            overflow-x: auto;
            margin-bottom: 10px;
        }
        
        .tab {
            padding: 8px 15px;
            background-color: #f0f0f0;
            border: none;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            margin-right: 2px;
        }
        
        .tab.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px;
            background-color: var(--dark-color);
            color: white;
            border-radius: 4px;
            z-index: 100;
            opacity: 0;
            transform: translateX(50px);
            transition: opacity 0.3s, transform 0.3s;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        
        .special-event {
            position: absolute;
            cursor: pointer;
            animation: pulse 1.5s infinite;
            z-index: 20;
            font-size: 40px;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .location-selector {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .location {
            padding: 10px;
            text-align: center;
            background-color: #f0f0f0;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .location:hover {
            background-color: #e4e4e4;
        }
        
        .location.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 500px;
            width: 80%;
        }
        
        .close {
            float: right;
            cursor: pointer;
            font-size: 24px;
        }
        
        .stats-container {
            margin-top: 15px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        /* Responsive styles */
        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-areas: 
                    "header"
                    "main"
                    "left-panel"
                    "right-panel"
                    "footer";
            }
            
            .left-panel, .right-panel {
                max-height: none;
            }
        }
        
        @media (max-width: 400px) {
            .resource-display {
                flex-direction: column;
            }
            
            .location-selector {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Ultimate Construction Clicker</h1>
            <div class="resource-display">
                <div class="resource">
                    <div>Score: <span id="score">0</span></div>
                    <div>Per click: <span id="scorePerClick">1.0</span></div>
                </div>
                <div class="resource">
                    <div>Multiplier: <span id="multiplier">1.0</span>x</div>
                    <div>Per second: <span id="scorePerSecond">0.0</span></div>
                </div>
                <div class="resource">
                    <div>Rebirth points: <span id="rebirthPoints">0</span></div>
                    <div>Offline earnings: <span id="offlineEarnings">0</span></div>
                </div>
            </div>
        </header>
        
        <div class="left-panel">
            <div class="tab-container">
                <button class="tab active" data-tab="upgrades">Upgrades</button>
                <button class="tab" data-tab="buildings">Buildings</button>
                <button class="tab" data-tab="prestige">Rebirth</button>
            </div>
            
            <div id="upgrades" class="tab-content active">
                <h2 class="section-title">Click Upgrades</h2>
                <div id="click-upgrades"></div>
                
                <h2 class="section-title">Cursor Upgrades</h2>
                <div id="cursor-upgrades"></div>
                
                <h2 class="section-title">Multipliers</h2>
                <div id="multiplier-upgrades"></div>
            </div>
            
            <div id="buildings" class="tab-content">
                <h2 class="section-title">Buildings</h2>
                <div id="building-list"></div>
            </div>
            
            <div id="prestige" class="tab-content">
                <h2 class="section-title">Rebirth</h2>
                <p>Restart with bonuses based on your current score.</p>
                <div id="rebirth-info">
                    <div>Current score: <span id="current-score">0</span></div>
                    <div>Rebirth points to gain: <span id="rebirth-gain">0</span></div>
                    <div>Current rebirth bonus: <span id="rebirth-bonus">0</span>%</div>
                </div>
                <button id="rebirth-button" class="button">Rebirth Now</button>
            </div>
        </div>
        
        <main class="main">
            <div id="location-name">Construction Site</div>
            <div class="game-area">
                <button class="click-button" id="clickButton">🚧</button>
                <div id="cursorContainer"></div>
                <div id="event-container"></div>
            </div>
            
            <div class="location-selector">
                <div class="location active" data-multiplier="1" data-name="Construction Site">
                    Construction Site (x1)
                </div>
                <div class="location" data-multiplier="2" data-name="Downtown Project" data-unlocked="false" data-required="500">
                    Downtown Project (x2)
                    <div>Unlock: 500 score</div>
                </div>
                <div class="location" data-multiplier="5" data-name="Skyscraper" data-unlocked="false" data-required="5000">
                    Skyscraper (x5)
                    <div>Unlock: 5000 score</div>
                </div>
                <div class="location" data-multiplier="10" data-name="Mega Complex" data-unlocked="false" data-required="50000">
                    Mega Complex (x10)
                    <div>Unlock: 50000 score</div>
                </div>
            </div>
        </main>
        
        <div class="right-panel">
            <h2 class="section-title">Statistics</h2>
            <div class="stats-container" id="stats-container">
                <div class="stat-item">
                    <span>Total clicks:</span>
                    <span id="total-clicks">0</span>
                </div>
                <div class="stat-item">
                    <span>Total score earned:</span>
                    <span id="total-score-earned">0</span>
                </div>
                <div class="stat-item">
                    <span>Total rebirths:</span>
                    <span id="total-rebirths">0</span>
                </div>
                <div class="stat-item">
                    <span>Play time:</span>
                    <span id="play-time">0m 0s</span>
                </div>
                <div class="stat-item">
                    <span>Special events triggered:</span>
                    <span id="events-triggered">0</span>
                </div>
            </div>
            
            <h2 class="section-title">Options</h2>
            <button id="save-button" class="button">Save Game</button>
            <button id="reset-button" class="button">Reset Progress</button>
            <button id="stats-button" class="button">View Full Stats</button>
        </div>
        
        <footer>
            <div>Created by Andrew a.k.a A41K</div>
        </footer>
    </div>
    
    <div id="notification" class="notification"></div>
    
    <div id="stats-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Game Statistics</h2>
            <div id="modal-stats-container"></div>
        </div>
    </div>

    <script>
        // Game state
        let state = {
            score: 0,
            scorePerClick: 1,
            scorePerSecond: 0,
            multiplier: 1,
            locationMultiplier: 1,
            rebirthPoints: 0,
            rebirthMultiplier: 1,
            totalClicks: 0,
            totalScoreEarned: 0,
            totalRebirths: 0,
            eventsTriggered: 0,
            lastSaved: Date.now(),
            startTime: Date.now(),
            playTime: 0,
            currentLocation: "Construction Site",
            unlockedLocations: ["Construction Site"],
            buildings: {},
            upgrades: {}
        };

        // Game config
        const SAVE_INTERVAL = 60000; // Auto-save every minute
        const TICK_INTERVAL = 1000; // Update game state every second
        const EVENT_CHANCE = 0.05; // 5% chance per minute for special event
        const EVENT_DURATION = 15000; // 15 seconds
        const REBIRTH_REQUIREMENT = 10000; // Score needed for first rebirth
        
        // Upgrade definitions
        const clickUpgrades = [
            { id: "click1", name: "Better Tools", cost: 50, baseCost: 50, effect: 0.5, level: 0, description: "Increase click value by 0.5", costIncrease: 1.5 },
            { id: "click2", name: "Heavy Machinery", cost: 500, baseCost: 500, effect: 2, level: 0, description: "Increase click value by 2", costIncrease: 1.6 },
            { id: "click3", name: "Expert Contractors", cost: 2500, baseCost: 2500, effect: 5, level: 0, description: "Increase click value by 5", costIncrease: 1.7 }
        ];
        
        const cursorUpgrades = [
            { id: "cursor1", name: "Hire Worker", cost: 10, baseCost: 10, effect: 0.2, level: 0, description: "Adds a worker producing 0.2 per second", costIncrease: 1.2 },
            { id: "cursor2", name: "Faster Workers", cost: 100, baseCost: 100, effect: 0.5, level: 0, description: "Each worker works 0.5 times faster", costIncrease: 1.4 },
            { id: "cursor3", name: "Worker Training", cost: 1000, baseCost: 1000, effect: 1, level: 0, description: "Each worker produces 1 more per second", costIncrease: 1.5 }
        ];
        
        const multiplierUpgrades = [
            { id: "multi1", name: "Efficiency Plans", cost: 200, baseCost: 200, effect: 0.1, level: 0, description: "Increases multiplier by 0.1", costIncrease: 2 },
            { id: "multi2", name: "Quality Materials", cost: 1000, baseCost: 1000, effect: 0.2, level: 0, description: "Increases multiplier by 0.2", costIncrease: 2.5 },
            { id: "multi3", name: "Modern Technology", cost: 5000, baseCost: 5000, effect: 0.5, level: 0, description: "Increases multiplier by 0.5", costIncrease: 3 }
        ];
        
        const buildings = [
            { id: "building1", name: "Small House", cost: 50, baseCost: 50, production: 0.5, level: 0, costIncrease: 1.15 },
            { id: "building2", name: "Apartment", cost: 300, baseCost: 300, production: 2, level: 0, costIncrease: 1.2 },
            { id: "building3", name: "Office Building", cost: 2000, baseCost: 2000, production: 8, level: 0, costIncrease: 1.25 },
            { id: "building4", name: "Shopping Mall", cost: 10000, baseCost: 10000, production: 25, level: 0, costIncrease: 1.3 }
        ];
        
        const rebirthUpgrades = [
            { id: "rebirth1", name: "Permanent Multiplier", cost: 5, baseCost: 5, effect: 0.2, level: 0, description: "Permanently increase your multiplier by 0.2", costIncrease: 1.5 },
            { id: "rebirth2", name: "Offline Earnings", cost: 10, baseCost: 10, effect: 0.1, level: 0, description: "Earn 10% of your production while offline", costIncrease: 2 },
            { id: "rebirth3", name: "Starting Bonus", cost: 15, baseCost: 15, effect: 100, level: 0, description: "Start each rebirth with 100 more score", costIncrease: 2.5 }
        ];
        
        // DOM elements
        const scoreElement = document.getElementById("score");
        const scorePerClickElement = document.getElementById("scorePerClick");
        const multiplierElement = document.getElementById("multiplier");
        const scorePerSecondElement = document.getElementById("scorePerSecond");
        const rebirthPointsElement = document.getElementById("rebirthPoints");
        const clickButton = document.getElementById("clickButton");
        const cursorContainer = document.getElementById("cursorContainer");
        const clickUpgradesContainer = document.getElementById("click-upgrades");
        const cursorUpgradesContainer = document.getElementById("cursor-upgrades");
        const multiplierUpgradesContainer = document.getElementById("multiplier-upgrades");
        const buildingListContainer = document.getElementById("building-list");
        const locationNameElement = document.getElementById("location-name");
        const rebirthButton = document.getElementById("rebirth-button");
        const currentScoreElement = document.getElementById("current-score");
        const rebirthGainElement = document.getElementById("rebirth-gain");
        const rebirthBonusElement = document.getElementById("rebirth-bonus");
        const totalClicksElement = document.getElementById("total-clicks");
        const totalScoreEarnedElement = document.getElementById("total-score-earned");
        const totalRebirthsElement = document.getElementById("total-rebirths");
        const playTimeElement = document.getElementById("play-time");
        const eventsTriggeredElement = document.getElementById("events-triggered");
        const saveButton = document.getElementById("save-button");
        const resetButton = document.getElementById("reset-button");
        const statsButton = document.getElementById("stats-button");
        const offlineEarningsElement = document.getElementById("offlineEarnings");
        const eventContainer = document.getElementById("event-container");
        const notification = document.getElementById("notification");
        const statsModal = document.getElementById("stats-modal");
        const closeModal = document.querySelector(".close");
        const modalStatsContainer = document.getElementById("modal-stats-container");
        
        // Initialize game
        function initGame() {
            // Load saved game or set defaults
            loadGame();
            
            // Initialize UI
            updateUI();
            
            // Setup event listeners
            setupEventListeners();
            
            // Start game loops
            setInterval(gameTick, TICK_INTERVAL);
            setInterval(saveGame, SAVE_INTERVAL);
            setInterval(checkForRandomEvent, 60000); // Check for random events every minute
            
            // Check for offline earnings
            checkOfflineEarnings();
            
            // Initialize upgrades
            initializeUpgrades();
            
            // Initialize workers from previous session
            for (let i = 0; i < (state.upgrades.cursor1?.level || 0); i++) {
                addCursor();
            }
        }
        
        // Initialize upgrades in the state
        function initializeUpgrades() {
            if (!state.upgrades) {
                state.upgrades = {};
            }
            
            // Combine all upgrades for initialization
            const allUpgrades = [...clickUpgrades, ...cursorUpgrades, ...multiplierUpgrades, ...rebirthUpgrades];
            
            for (const upgrade of allUpgrades) {
                if (!state.upgrades[upgrade.id]) {
                    state.upgrades[upgrade.id] = {
                        level: 0,
                        cost: upgrade.baseCost
                    };
                }
            }
            
            if (!state.buildings) {
                state.buildings = {};
            }
            
            for (const building of buildings) {
                if (!state.buildings[building.id]) {
                    state.buildings[building.id] = {
                        level: 0,
                        cost: building.baseCost
                    };
                }
            }
            
            renderUpgrades();
            renderBuildings();
        }
        
        // Render upgrades to DOM
        function renderUpgrades() {
            // Render click upgrades
            clickUpgradesContainer.innerHTML = "";
            for (const upgrade of clickUpgrades) {
                const upgradeState = state.upgrades[upgrade.id];
                const div = document.createElement("div");
                div.className = "upgrade-item";
                div.innerHTML = `
                    <div>
                        <div>${upgrade.name} (Level ${upgradeState.level})</div>
                        <div>${upgrade.description}</div>
                    </div>
                    <button class="button" data-upgrade="${upgrade.id}">Buy for ${formatNumber(upgradeState.cost)}</button>
                `;
                clickUpgradesContainer.appendChild(div);
            }
            
            // Render cursor upgrades
            cursorUpgradesContainer.innerHTML = "";
            for (const upgrade of cursorUpgrades) {
                const upgradeState = state.upgrades[upgrade.id];
                const div = document.createElement("div");
                div.className = "upgrade-item";
                div.innerHTML = `
                    <div>
                        <div>${upgrade.name} (Level ${upgradeState.level})</div>
                        <div>${upgrade.description}</div>
                    </div>
                    <button class="button" data-upgrade="${upgrade.id}">Buy for ${formatNumber(upgradeState.cost)}</button>
                `;
                cursorUpgradesContainer.appendChild(div);
            }
            
            // Render multiplier upgrades
            multiplierUpgradesContainer.innerHTML = "";
            for (const upgrade of multiplierUpgrades) {
                const upgradeState = state.upgrades[upgrade.id];
                const div = document.createElement("div");
                div.className = "upgrade-item";
                div.innerHTML = `
                    <div>
                        <div>${upgrade.name} (Level ${upgradeState.level})</div>
                        <div>${upgrade.description}</div>
                    </div>
                    <button class="button" data-upgrade="${upgrade.id}">Buy for ${formatNumber(upgradeState.cost)}</button>
                `;
                multiplierUpgradesContainer.appendChild(div);
            }
        }
        
        // Render buildings to DOM
        function renderBuildings() {
            buildingListContainer.innerHTML = "";
            for (const building of buildings) {
                const buildingState = state.buildings[building.id];
                const div = document.createElement("div");
                div.className = "building-item";
                div.innerHTML = `
                    <div>
                        <div>${building.name} (Level ${buildingState.level})</div>
                        <div>Produces ${formatNumber(building.production)} per second</div>
                    </div>
                    <button class="button" data-building="${building.id}">Buy for ${formatNumber(buildingState.cost)}</button>
                `;
                buildingListContainer.appendChild(div);
            }
        }
        
        // Update game state every tick
        function gameTick() {
            // Calculate production from buildings
            let production = 0;
            for (const building of buildings) {
                production += building.production * (state.buildings[building.id]?.level || 0);
            }
            
            // Add production from cursors
            const cursorProduction = calculateCursorProduction();
            production += cursorProduction;
            
            // Apply multipliers
            production *= state.multiplier;
            production *= state.locationMultiplier;
            production *= state.rebirthMultiplier;
            
            // Add to score
            if (production > 0) {
                addScore(production / (1000 / TICK_INTERVAL)); // Adjust for tick interval
            }
            
            // Update per second display
            state.scorePerSecond = production;
            
            // Update UI
            updateUI();
            
            // Check for location unlocks
            checkLocationUnlocks();
            
            // Update play time
            state.playTime += TICK_INTERVAL / 1000;
            updatePlayTimeDisplay();
        }
        
        // Calculate production from cursors
        function calculateCursorProduction() {
            const cursorCount = state.upgrades.cursor1?.level || 0;
            let baseProduction = 0.2 * cursorCount;
            
            // Apply cursor speed upgrade
            const speedUpgrade = state.upgrades.cursor2?.level || 0;
            baseProduction *= (1 + (0.5 * speedUpgrade));
            
            // Apply cursor efficiency upgrade
            const efficiencyUpgrade = state.upgrades.cursor3?.level || 0;
            baseProduction += (1 * efficiencyUpgrade * cursorCount);
            
            return baseProduction;
        }
        
        // Update UI elements
        function updateUI() {
            scoreElement.textContent = formatNumber(state.score);
            scorePerClickElement.textContent = formatNumber(state.scorePerClick);
            multiplierElement.textContent = formatNumber(state.multiplier * state.locationMultiplier * state.rebirthMultiplier);
            scorePerSecondElement.textContent = formatNumber(state.scorePerSecond);
            rebirthPointsElement.textContent = formatNumber(state.rebirthPoints);
            
            totalClicksElement.textContent = formatNumber(state.totalClicks);
            totalScoreEarnedElement.textContent = formatNumber(state.totalScoreEarned);
            totalRebirthsElement.textContent = formatNumber(state.totalRebirths);
            eventsTriggeredElement.textContent = formatNumber(state.eventsTriggered);
            
            // Update rebirth information
            currentScoreElement.textContent = formatNumber(state.score);
            const rebirthGain = calculateRebirthGain();
            rebirthGainElement.textContent = formatNumber(rebirthGain);
            rebirthBonusElement.textContent = ((state.rebirthMultiplier - 1) * 100).toFixed(0);
            
            // Update button states
            updateButtonStates();
        }
        
        // Update button states based on available score
        function updateButtonStates() {
            // Click upgrade buttons
            const upgradeButtons = document.querySelectorAll('[data-upgrade]');
            upgradeButtons.forEach(button => {
                const upgradeId = button.getAttribute('data-upgrade');
                let upgrade;
                
                if (upgradeId.startsWith('click')) {
                    upgrade = clickUpgrades.find(u => u.id === upgradeId);
                } else if (upgradeId.startsWith('cursor')) {
                    upgrade = cursorUpgrades.find(u => u.id === upgradeId);
                } else if (upgradeId.startsWith('multi')) {
                    upgrade = multiplierUpgrades.find(u => u.id === upgradeId);
                } else if (upgradeId.startsWith('rebirth')) {
                    upgrade = rebirthUpgrades.find(u => u.id === upgradeId);
                }
                
                if (upgrade) {
                    const upgradeState = state.upgrades[upgradeId];
                    button.disabled = state.score < upgradeState.cost;
                }
            });
            
            // Building buttons
            const buildingButtons = document.querySelectorAll('[data-building]');
            buildingButtons.forEach(button => {
                const buildingId = button.getAttribute('data-building');
                const building = buildings.find(b => b.id === buildingId);
                if (building) {
                    const buildingState = state.buildings[buildingId];
                    button.disabled = state.score < buildingState.cost;
                }
            });
            
            // Rebirth button
            rebirthButton.disabled = state.score < REBIRTH_REQUIREMENT;
        }
        
        // Handle click on main button
        function handleMainClick(event) {
            // Calculate score to add
            const scoreToAdd = state.scorePerClick * state.multiplier * state.locationMultiplier * state.rebirthMultiplier;
            
            // Add to score
            addScore(scoreToAdd);
            
            // Increment total clicks
            state.totalClicks++;
            
            // Show floating text
            showFloatingText(scoreToAdd);
            
            // Update UI
            updateUI();
        }
        
        // Add score and update total earned
        function addScore(amount) {
            state.score += amount;
            state.totalScoreEarned += amount;
        }
        
        // Show floating text when clicking
        function showFloatingText(amount) {
            const floatingText = document.createElement("div");
            floatingText.className = "floating-text";
            floatingText.textContent = "+" + formatNumber(amount);
            
            // Random position near click area
            const button = clickButton.getBoundingClientRect();
            const gameArea = document.querySelector(".game-area");
            const x = button.left + button.width/2 + (Math.random() * 60 - 30);
            const y = button.top + button.height/2 + (Math.random() * 40 - 20);
            
            floatingText.style.left = (x - gameArea.getBoundingClientRect().left) + "px";
            floatingText.style.top = (y - gameArea.getBoundingClientRect().top) + "px";
            
            gameArea.appendChild(floatingText);
            
            // Remove after animation completes
            setTimeout(() => {
                if (floatingText.parentNode) {
                    floatingText.parentNode.removeChild(floatingText);
                }
            }, 1500);
        }
        
        // Purchase upgrade
        function purchaseUpgrade(upgradeId) {
            let upgrade;
            let upgradeList;
            
            if (upgradeId.startsWith('click')) {
                upgradeList = clickUpgrades;
                upgrade = clickUpgrades.find(u => u.id === upgradeId);
            } else if (upgradeId.startsWith('cursor')) {
                upgradeList = cursorUpgrades;
                upgrade = cursorUpgrades.find(u => u.id === upgradeId);
            } else if (upgradeId.startsWith('multi')) {
                upgradeList = multiplierUpgrades;
                upgrade = multiplierUpgrades.find(u => u.id === upgradeId);
            } else if (upgradeId.startsWith('rebirth')) {
                upgradeList = rebirthUpgrades;
                upgrade = rebirthUpgrades.find(u => u.id === upgradeId);
            }
            
            if (!upgrade) return;
            
            const upgradeState = state.upgrades[upgradeId];
            
            // Check if player has enough score
            if (state.score < upgradeState.cost) {
                showNotification("Not enough score to purchase this upgrade!");
                return;
            }
            
            // Subtract cost
            state.score -= upgradeState.cost;
            
            // Increase level
            upgradeState.level++;
            
            // Update cost
            upgradeState.cost = Math.round(upgrade.baseCost * Math.pow(upgrade.costIncrease, upgradeState.level));
            
            // Apply effect
            applyUpgradeEffect(upgrade, upgradeId);
            
            // Add cursor if it's the first upgrade
            if (upgradeId === "cursor1") {
                addCursor();
            }
            
            // Update UI
            renderUpgrades();
            updateUI();
            
            showNotification(`Purchased ${upgrade.name} (Level ${upgradeState.level})`);
        }
        
        // Apply upgrade effect
        function applyUpgradeEffect(upgrade, upgradeId) {
            if (upgradeId.startsWith('click')) {
                state.scorePerClick += upgrade.effect;
            } else if (upgradeId.startsWith('multi')) {
                state.multiplier += upgrade.effect;
            } else if (upgradeId === 'rebirth1') {
                state.rebirthMultiplier += upgrade.effect;
            }
            // Cursor upgrades are applied in the production calculation
        }
        
        // Purchase building
        function purchaseBuilding(buildingId) {
            const building = buildings.find(b => b.id === buildingId);
            if (!building) return;
            
            const buildingState = state.buildings[buildingId];
            
            // Check if player has enough score
            if (state.score < buildingState.cost) {
                showNotification("Not enough score to purchase this building!");
                return;
            }
            
            // Subtract cost
            state.score -= buildingState.cost;
            
            // Increase level
            buildingState.level++;
            
            // Update cost
            buildingState.cost = Math.round(building.baseCost * Math.pow(building.costIncrease, buildingState.level));
            
            // Update UI
            renderBuildings();
            updateUI();
            
            showNotification(`Purchased ${building.name} (Level ${buildingState.level})`);
        }
        
        // Add cursor worker
        function addCursor() {
            const cursor = document.createElement("div");
            cursor.className = "cursor";
            cursor.innerHTML = "👷";
            
            // Random position
            const gameArea = document.querySelector(".game-area");
            const areaRect = gameArea.getBoundingClientRect();
            
            const radius = Math.min(areaRect.width, areaRect.height) / 2 - 30;
            const angle = Math.random() * Math.PI * 2;
            
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            
            cursor.style.left = (areaRect.width/2 + x) + "px";
            cursor.style.top = (areaRect.height/2 + y) + "px";
            
            // Random animation
            const animationDuration = 5 + Math.random() * 10;
            cursor.style.animation = `rotation ${animationDuration}s linear infinite`;
            cursor.style.transformOrigin = `${-x}px ${-y}px`;
            
            // Add to container
            cursorContainer.appendChild(cursor);
        }
        
        // Handle rebirth
        function handleRebirth() {
            if (state.score < REBIRTH_REQUIREMENT) {
                showNotification("You need at least " + formatNumber(REBIRTH_REQUIREMENT) + " score to rebirth!");
                return;
            }
            
            const rebirthGain = calculateRebirthGain();
            state.rebirthPoints += rebirthGain;
            
            // Apply permanent rebirth bonus
            const startingBonus = (state.upgrades.rebirth3?.level || 0) * 100;
            
            // Reset state but keep persistent upgrades and stats
            state = {
                score: startingBonus,
                scorePerClick: 1,
                scorePerSecond: 0,
                multiplier: 1,
                locationMultiplier: 1,
                rebirthPoints: state.rebirthPoints,
                rebirthMultiplier: state.rebirthMultiplier,
                totalClicks: state.totalClicks,
                totalScoreEarned: state.totalScoreEarned,
                totalRebirths: state.totalRebirths + 1,
                eventsTriggered: state.eventsTriggered,
                lastSaved: Date.now(),
                startTime: state.startTime,
                playTime: state.playTime,
                currentLocation: "Construction Site",
                unlockedLocations: ["Construction Site"],
                buildings: {},
                upgrades: {
                    rebirth1: state.upgrades.rebirth1,
                    rebirth2: state.upgrades.rebirth2,
                    rebirth3: state.upgrades.rebirth3
                }
            };
            
            // Clear cursors
            cursorContainer.innerHTML = "";
            
            // Re-initialize upgrades
            initializeUpgrades();
            
            // Update locations
            updateLocationDisplay();
            
            // Show notification
            showNotification(`Rebirth complete! Gained ${formatNumber(rebirthGain)} rebirth points.`);
            
            // Update UI
            updateUI();
        }
        
        // Calculate rebirth gain
        function calculateRebirthGain() {
            return Math.floor(Math.sqrt(state.score / REBIRTH_REQUIREMENT));
        }
        
        // Purchase rebirth upgrade
        function purchaseRebirthUpgrade(upgradeId) {
            const upgrade = rebirthUpgrades.find(u => u.id === upgradeId);
            if (!upgrade) return;
            
            const upgradeState = state.upgrades[upgradeId];
            
            // Check if player has enough rebirth points
            if (state.rebirthPoints < upgradeState.cost) {
                showNotification("Not enough rebirth points!");
                return;
            }
            
            // Subtract cost
            state.rebirthPoints -= upgradeState.cost;
            
            // Increase level
            upgradeState.level++;
            
            // Update cost
            upgradeState.cost = Math.round(upgrade.baseCost * Math.pow(upgrade.costIncrease, upgradeState.level));
            
            // Apply effect
            if (upgradeId === "rebirth1") {
                state.rebirthMultiplier += upgrade.effect;
            }
            
            // Update UI
            renderUpgrades();
            updateUI();
            
            showNotification(`Purchased ${upgrade.name} (Level ${upgradeState.level})`);
        }
        
        // Check for location unlocks
        function checkLocationUnlocks() {
            const locations = document.querySelectorAll('.location');
            locations.forEach(location => {
                const required = parseInt(location.getAttribute('data-required') || 0);
                const name = location.getAttribute('data-name');
                
                if (required && state.score >= required && !state.unlockedLocations.includes(name)) {
                    state.unlockedLocations.push(name);
                    location.removeAttribute('data-unlocked');
                    showNotification(`New location unlocked: ${name}!`);
                }
            });
            
            updateLocationDisplay();
        }
        
        // Update location display
        function updateLocationDisplay() {
            const locations = document.querySelectorAll('.location');
            locations.forEach(location => {
                const name = location.getAttribute('data-name');
                const isUnlocked = state.unlockedLocations.includes(name);
                
                if (isUnlocked) {
                    location.innerHTML = `${name} (x${location.getAttribute('data-multiplier')})`;
                    location.style.cursor = 'pointer';
                    location.classList.toggle('active', state.currentLocation === name);
                } else {
                    location.style.cursor = 'not-allowed';
                    location.classList.remove('active');
                }
            });
        }
        
        // Change location
        function changeLocation(location) {
            const name = location.getAttribute('data-name');
            const multiplier = parseFloat(location.getAttribute('data-multiplier'));
            
            if (!state.unlockedLocations.includes(name)) {
                showNotification(`You haven't unlocked this location yet!`);
                return;
            }
            
            state.currentLocation = name;
            state.locationMultiplier = multiplier;
            locationNameElement.textContent = name;
            
            document.querySelectorAll('.location').forEach(loc => {
                loc.classList.toggle('active', loc.getAttribute('data-name') === name);
            });
            
            showNotification(`Moved to ${name}! Multiplier: x${multiplier}`);
            updateUI();
        }
        
        // Check for random events
        function checkForRandomEvent() {
            if (Math.random() < EVENT_CHANCE) {
                spawnSpecialEvent();
            }
        }
        
        // Spawn special event
        function spawnSpecialEvent() {
            const eventTypes = ["🚁", "💰", "⚡", "🌟"];
            const eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
            
            const event = document.createElement("div");
            event.className = "special-event";
            event.textContent = eventType;
            
            // Random position
            const gameArea = document.querySelector(".game-area");
            const rect = gameArea.getBoundingClientRect();
            
            const x = Math.random() * (rect.width - 50);
            const y = Math.random() * (rect.height - 50);
            
            event.style.left = x + "px";
            event.style.top = y + "px";
            
            // Add event listener
            event.addEventListener("click", () => {
                collectSpecialEvent(event, eventType);
            });
            
            // Add to container
            eventContainer.appendChild(event);
            
            // Remove after duration
            setTimeout(() => {
                if (event.parentNode) {
                    event.parentNode.removeChild(event);
                }
            }, EVENT_DURATION);
            
            showNotification("Special event appeared! Click it quickly!");
        }
        
        // Collect special event
        function collectSpecialEvent(event, type) {
            // Remove event element
            if (event.parentNode) {
                event.parentNode.removeChild(event);
            }
            
            let reward = "";
            
            // Apply effect based on type
            switch(type) {
                case "🚁":
                    // Temporary boost to score per click
                    const clickBoost = state.scorePerClick * 10;
                    state.scorePerClick += clickBoost;
                    reward = `Score per click boosted by ${formatNumber(clickBoost)} for 20 seconds!`;
                    setTimeout(() => {
                        state.scorePerClick -= clickBoost;
                        updateUI();
                        showNotification("Click boost ended.");
                    }, 20000);
                    break;
                case "💰":
                    // Instant cash bonus
                    const cashBonus = state.score * 0.5;
                    addScore(cashBonus);
                    reward = `Received ${formatNumber(cashBonus)} instant bonus!`;
                    break;
                case "⚡":
                    // Production speed boost
                    const speedBoost = state.scorePerSecond * 2;
                    state.scorePerSecond += speedBoost;
                    reward = `Production boosted by ${formatNumber(speedBoost)} for 30 seconds!`;
                    setTimeout(() => {
                        state.scorePerSecond -= speedBoost;
                        updateUI();
                        showNotification("Production boost ended.");
                    }, 30000);
                    break;
                case "🌟":
                    // Multiplier boost
                    const multiplierBoost = 2;
                    state.multiplier *= multiplierBoost;
                    reward = `Multiplier doubled for 15 seconds!`;
                    setTimeout(() => {
                        state.multiplier /= multiplierBoost;
                        updateUI();
                        showNotification("Multiplier boost ended.");
                    }, 15000);
                    break;
            }
            
            // Update stats
            state.eventsTriggered++;
            
            // Show notification
            showNotification(`Event collected! ${reward}`);
            
            // Update UI
            updateUI();
        }
        
        // Check for offline earnings
        function checkOfflineEarnings() {
            const lastSaved = state.lastSaved || Date.now();
            const offlineTime = Date.now() - lastSaved;
            
            if (offlineTime < 10000) return; // Less than 10 seconds, ignore
            
            // Calculate offline earnings
            const offlineHours = offlineTime / (1000 * 60 * 60);
            const offlineMultiplier = state.upgrades.rebirth2 ? state.upgrades.rebirth2.level * 0.1 : 0;
            
            if (offlineMultiplier <= 0) return; // No offline earnings upgrade
            
            const offlinePerSecond = state.scorePerSecond * offlineMultiplier;
            const offlineEarnings = offlinePerSecond * offlineTime / 1000;
            
            if (offlineEarnings > 0) {
                addScore(offlineEarnings);
                offlineEarningsElement.textContent = formatNumber(offlineEarnings);
                showNotification(`Welcome back! You earned ${formatNumber(offlineEarnings)} while away.`);
            }
        }
        
        // Show notification
        function showNotification(message) {
            notification.textContent = message;
            notification.classList.add("show");
            
            setTimeout(() => {
                notification.classList.remove("show");
            }, 3000);
        }
        
        // Update play time display
        function updatePlayTimeDisplay() {
            const seconds = Math.floor(state.playTime % 60);
            const minutes = Math.floor(state.playTime / 60) % 60;
            const hours = Math.floor(state.playTime / 3600);
            
            let timeString = "";
            if (hours > 0) {
                timeString += `${hours}h `;
            }
            timeString += `${minutes}m ${seconds}s`;
            
            playTimeElement.textContent = timeString;
        }
        
        // Format large numbers for display
        function formatNumber(num) {
            if (num >= 1e12) return (num / 1e12).toFixed(2) + "T";
            if (num >= 1e9) return (num / 1e9).toFixed(2) + "B";
            if (num >= 1e6) return (num / 1e6).toFixed(2) + "M";
            if (num >= 1e3) return (num / 1e3).toFixed(2) + "K";
            return num.toFixed(1);
        }
        
        // Save game state
        function saveGame() {
            state.lastSaved = Date.now();
            localStorage.setItem("constructionClickerSave", JSON.stringify(state));
            console.log("Game saved:", state.lastSaved);
        }
        
        // Load game state
        function loadGame() {
            const savedGame = localStorage.getItem("constructionClickerSave");
            if (savedGame) {
                try {
                    const loadedState = JSON.parse(savedGame);
                    state = loadedState;
                    console.log("Game loaded from save.");
                } catch (e) {
                    console.error("Error loading saved game:", e);
                }
            }
        }
        
        // Reset game
        function resetGame() {
            if (confirm("Are you sure you want to reset all progress? This cannot be undone!")) {
                localStorage.removeItem("constructionClickerSave");
                location.reload();
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Main click button
            clickButton.addEventListener("click", handleMainClick);
            
            // Tab buttons
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.getAttribute('data-tab');
                    
                    document.querySelectorAll('.tab').forEach(t => {
                        t.classList.toggle('active', t === tab);
                    });
                    
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.toggle('active', content.id === tabName);
                    });
                });
            });
            
            // Upgrade buttons
            document.addEventListener('click', e => {
                if (e.target.hasAttribute('data-upgrade')) {
                    const upgradeId = e.target.getAttribute('data-upgrade');
                    purchaseUpgrade(upgradeId);
                }
            });
            
            // Building buttons
            document.addEventListener('click', e => {
                if (e.target.hasAttribute('data-building')) {
                    const buildingId = e.target.getAttribute('data-building');
                    purchaseBuilding(buildingId);
                }
            });
            
            // Location selection
            document.querySelectorAll('.location').forEach(location => {
                location.addEventListener('click', () => {
                    changeLocation(location);
                });
            });
            
            // Rebirth button
            rebirthButton.addEventListener('click', handleRebirth);
            
            // Save button
            saveButton.addEventListener('click', () => {
                saveGame();
                showNotification("Game saved successfully!");
            });
            
            // Reset button
            resetButton.addEventListener('click', resetGame);
            
            // Stats button
            statsButton.addEventListener('click', () => {
                showStatsModal();
            });
            
            // Close modal
            closeModal.addEventListener('click', () => {
                statsModal.style.display = "none";
            });
            
            // Close modal on outside click
            window.addEventListener('click', (e) => {
                if (e.target === statsModal) {
                    statsModal.style.display = "none";
                }
            });
        }
        
        // Show stats modal
        function showStatsModal() {
            modalStatsContainer.innerHTML = `
                <div class="stat-item"><span>Total clicks:</span><span>${formatNumber(state.totalClicks)}</span></div>
                <div class="stat-item"><span>Total score earned:</span><span>${formatNumber(state.totalScoreEarned)}</span></div>
                <div class="stat-item"><span>Total rebirths:</span><span>${formatNumber(state.totalRebirths)}</span></div>
                <div class="stat-item"><span>Play time:</span><span>${playTimeElement.textContent}</span></div>
                <div class="stat-item"><span>Special events triggered:</span><span>${formatNumber(state.eventsTriggered)}</span></div>
                <div class="stat-item"><span>Current score per click:</span><span>${formatNumber(state.scorePerClick)}</span></div>
                <div class="stat-item"><span>Current score per second:</span><span>${formatNumber(state.scorePerSecond)}</span></div>
                <div class="stat-item"><span>Current multiplier:</span><span>${formatNumber(state.multiplier * state.locationMultiplier * state.rebirthMultiplier)}</span></div>
                <div class="stat-item"><span>Total buildings owned:</span><span>${calculateTotalBuildings()}</span></div>
            `;
            
            statsModal.style.display = "flex";
        }
        
        // Calculate total buildings
        function calculateTotalBuildings() {
            let total = 0;
            for (const building of buildings) {
                total += state.buildings[building.id]?.level || 0;
            }
            return total;
        }
        
        // Start the game
        window.addEventListener("load", initGame);
        
        // Prevent context menu on click button
        clickButton.addEventListener("contextmenu", (e) => {
            e.preventDefault();
        });
    </script>
</body>
</html>